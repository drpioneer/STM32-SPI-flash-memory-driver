/*
 *  Драйвер для работы с м/сх FLASH-памяти через SPI: Adesto AT45DBXXX/ Winbond W25QXX и др.
 *  Источники кода:     https://github.com/nimaltd/45dbxxx
 *                      https://github.com/nimaltd/w25qxx
 *                      https://github.com/iDiy/AT45DB161D-Drv
 *                      https://github.com/stDstm/Example_STM32F103/tree/master/W25QXX_Flash_SPI_F103
 *  Описание работы:    http: //we.easyelectronics.ru/Frankie/spi-programmnyy-pamyat-atmel-dataflash-at45db081d.html
 *                      https://eax.me/stm32-spi-flash/
 *  Настройки SPI1 в CubeMX для работы с микросхемой FLASH-памяти:
 *                      Frame format: Motorola      Data size: 8 bit            First bit: MSB;
 *                      CPOL: LOW                   CPHA:      1 Edge
 *                      CRC:  Disabled              NSS:       Software
 *  Особенности работы с FLASH-памятью в данном драйвере:
 *      - после подачи питания и перед обращением к памяти необходимо сделать гарантированную задержку в 20 миллисекунд
 *      - обмен данными производится по 4-х проводному интерфейсу SPI в режиме 0
 *      - организация памяти блочная, доступ к отдельным ячейкам памяти отсутствует
 *      - операция удаления может быть выполнена только для: чипа или области (сектора или страницы памяти)
 *      - все операции чтения/записи происходят по принципу «чтение-модификация-запись»
 *      - размер страницы зависит от конкретной м/сх памяти, страницы логически объединяются в сектора и блоки памяти
 *      - для AT45DBXXX: блок памяти содержит в 8 страниц; сектор памяти содержит 128/256/512/1024 страниц; логическая организация памяти: страница->блок->сектор
 *      - для W25QXXX:   сектор памяти содержит 16 страниц; блок памяти содержит 256 страниц; логическая организация памяти: страница->сектор->блок
 *      - в конце кода драйвера прикручены функции-прокладки, необходимые для обеспечения совместной работы с LittleFS
 */

#include "spiflash.h"

#define _FLASH_SPI              hspi1                                           // осуществление взаимодействия с м/сх FLASH-памяти по SPI1
#define _FLASH_CS_GPIO          SPI1_NSS_GPIO_Port                              // определение порта Chip Select Flash (Negative SS SPI1)
#define _FLASH_CS_PIN           SPI1_NSS_Pin
#define _FLASH_WP_GPIO          NWP_FLSH_GPIO_Port                              // определение порта Write Protect Flash (Negative WP)
#define _FLASH_WP_PIN           NWP_FLSH_Pin
#define _FLASH_RST_GPIO         NRST_FLSH_GPIO_Port                             // определение порта Reset Flash
#define _FLASH_RST_PIN          NRST_FLSH_Pin



#define _FLASH_USE_FREERTOS     1                                               // =1 -> работа в многозадачной среде
#if (_FLASH_USE_FREERTOS == 1)
    #include "cmsis_os.h"
    #define _FLASH_DELAY(x)     osDelay(x)
#else
    #define _FLASH_DELAY(x)     HAL_Delay(x)
#endif

FLASH_t          flash;

// ------------------------------- Базовые функции для работы с м/сх FLASH-памяти: -----------------------------------------------------

uint8_t Flash_Spi           (uint8_t data)                                      // функция одновременного чтения/отправки посылки из 8 бит из/в микросхемы(у) FLASH-памяти
{
    uint8_t ret             = 0;
    HAL_SPI_TransmitReceive(&_FLASH_SPI, &data, &ret, 1, 10);                   // отправка/чтение заданной команды/данных
    return ret;
}

void Flash_ChipSelect       (bool available)                                    // функция запрета/разрешения работы с м/сх памяти
{
    if (available)
        HAL_GPIO_WritePin   (_FLASH_CS_GPIO, _FLASH_CS_PIN, GPIO_PIN_RESET);    // разрешение работы с м/сх памяти
    else
        HAL_GPIO_WritePin   (_FLASH_CS_GPIO, _FLASH_CS_PIN, GPIO_PIN_SET);      // запрет работы с м/сх памяти
}

void Flash_WriteEnable      (bool available)                                    // функция запрета/разрешения записи в м/сх памяти
{
    if (available)
        HAL_GPIO_WritePin   (_FLASH_WP_GPIO, _FLASH_WP_PIN, GPIO_PIN_RESET);    // аппаратное разрешение записи в м/сх памяти
    else
        HAL_GPIO_WritePin   (_FLASH_WP_GPIO, _FLASH_WP_PIN, GPIO_PIN_SET);      // аппаратный запрет записи в м/сх памяти
}

void Flash_Reset            (void)                                              // функция аппаратного сброса м/сх памяти
{
    HAL_GPIO_WritePin   (_FLASH_RST_GPIO, _FLASH_RST_PIN, GPIO_PIN_RESET);      // активация аппаратного сброса м/сх памяти
    _FLASH_DELAY        (DELAY);
    HAL_GPIO_WritePin   (_FLASH_RST_GPIO, _FLASH_RST_PIN, GPIO_PIN_SET);        // деактивация аппаратного сброса м/сх памяти
}

bool Flash_Init             (void)                                              // функция инициализации микросхемы flash-памяти
{
    flash.Busy              = true;                                             // установка флага занятости м/сх памяти
    flash.Id                = 0;                                                // подготовка переменной для номера-идентификатора м/сх памяти. 0 -> м/сх не опознана, 1-255 -> м/сх идентифицирована
    uint32_t Id             = 0;
    Flash_Reset             ();                                                 // аппаратный сброс м/сх памяти
    Flash_ChipSelect        (false);                                            // подготовка после включения
    while (HAL_GetTick() < 20)                                                  // обеспечение принудительной задержки перед инициализацией м/сх
        _FLASH_DELAY        (DELAY/10);
    Flash_ChipSelect        (true);                                             // разрешение работы с м/сх памяти
    Flash_Spi               (FLASH_GET_JEDEC_ID);                               // отправка команды: 0x9F - "считывание идентификатора производителя и устройства"
    uint8_t  mnfId          = Flash_Spi(DUMMY_BYTE);                            // чтение Manufacturer ID
    Id                      = Id | (Flash_Spi(DUMMY_BYTE) << 24);               // чтение Device ID Byte 1
    Id                      = Id | (Flash_Spi(DUMMY_BYTE) << 16);               // чтение Device ID Byte 2
    Id                      = Id | (Flash_Spi(DUMMY_BYTE) << 8);                // чтение Extended Device Information String Length
    Id                      = Id |  Flash_Spi(DUMMY_BYTE);                      // чтение Extended Device Information Byte 1
    Flash_ChipSelect        (false);                                            // завершение работы с м/сх памяти

    if (mnfId == AT45_ADESTO)                                                   // когда идентификатор производителя =0x1F (ADESTO/ATMEL)  ->
    {
        switch (Id)                                                             // идентификация м/сх памяти ->
        {
            case 0x22000000:                                                    // at45db011d - 1Mbit/128Kb
                flash.Pages = 512;                                              // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 1;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x22000001:                                                    // at45db011d - 1Mbit/128Kb
                flash.Pages = 512;                                              // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 2;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x23000100:                                                    // at45db021e - 2Mbit/256Kb
                flash.Pages = 1024;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 3;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x23000101:                                                    // at45db021e - 2Mbit/256Kb
                flash.Pages = 1024;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 4;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x24000100:                                                    // at45db041e - 4Mbit/512Kb
                flash.Pages = 2048;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 5;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x24000101:                                                    // at45db041e - 4Mbit/512Kb
                flash.Pages = 2048;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 6;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x25000000:                                                    // at45db081d - 8Mbit/1Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 7;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x25000001:                                                    // at45db081d - 8Mbit/1Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 8;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x25000100:                                                    // at45db081e - 8Mbit/1Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 9;                                                // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x25000101:                                                    // at45db081e - 8Mbit/1Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 10;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x26000000:                                                    // at45db161d - 16Mbit/2Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 528;                                              // размер одной страницы памяти в байтах
                flash.Shift = 10;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 11;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x26000001:                                                    // at45db161d - 16Mbit/2Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 512;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 12;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x26000100:                                                    // at45db161e - 16Mbit/2Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 528;                                              // размер одной страницы памяти в байтах
                flash.Shift = 10;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 13;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x26000101:                                                    // at45db161e - 16Mbit/2Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 512;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 14;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x27000000:                                                    // at45db321d - 32Mbit/4Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 528;                                              // размер одной страницы памяти в байтах
                flash.Shift = 10;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 15;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x27000001:                                                    // at45db321d - 32Mbit/4Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 512;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 16;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x27010100:                                                    // at45db321e - 32Mbit/4Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 528;                                              // размер одной страницы памяти в байтах
                flash.Shift = 10;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 17;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x27010101:                                                    // at45db321e - 32Mbit/4Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 512;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 18;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x28000000:                                                    // at45db642d - 64Mbit/8Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 1056;                                             // размер одной страницы памяти в байтах
                flash.Shift = 11;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 19;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x28000001:                                                    // at45db642d - 64Mbit/8Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.PgSize= 1024;                                             // размер одной страницы памяти в байтах
                flash.Shift = 10;                                               // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 20;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x28000100:                                                    // at45db641e - 64Mbit/8Mb
                flash.Pages = 32768;                                            // общее количество страниц памяти на м/сх
                flash.PgSize= 264;                                              // размер одной страницы памяти в байтах
                flash.Shift = 9;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 21;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x28000101:                                                    // at45db641e - 64Mbit/8Mb
                flash.Pages = 32768;                                            // общее количество страниц памяти на м/сх
                flash.PgSize= 256;                                              // размер одной страницы памяти в байтах
                flash.Shift = 8;                                                // число фиктивных битов сдвига для вычисления абсолютного адреса
                flash.Id    = 22;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

        }
        flash.ErasableSize  = flash.PgSize;                                     // минимальный размер стираемого блока (только для LittleFS)
        flash.NumOfErasable = flash.Pages;                                      // общее количество стираемых блоков   (только для LittleFS)
    }
    else
    if (mnfId == W25_WINBOND || mnfId == MX25_MACRONIX)                         // когда идентификатор производителя =0xEF (Winbond) или =0xC2 (Macronix) ->
    {
        switch ((Id & 0x00FF0000) >> 16)                                        // идентификация м/сх памяти ->
        {
            case 0x11:                                                          // w25q10 - 1Mbit/128Kb
                flash.Pages = 512;                                              // общее количество страниц памяти на м/сх
                flash.Id    = 64;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x12:                                                          // w25q20 - 2Mbit/256Kb
                flash.Pages = 1024;                                             // общее количество страниц памяти на м/сх
                flash.Id    = 65;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x13:                                                          // w25q40 - 4Mbit/512Kb
                flash.Pages = 2048;                                             // общее количество страниц памяти на м/сх
                flash.Id    = 66;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x14:                                                          // w25q80 - 8Mbit/1Mb
                flash.Pages = 4096;                                             // общее количество страниц памяти на м/сх
                flash.Id    = 67;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x15:                                                          // w25q16 - 16Mbit/2Mb
                flash.Pages = 8192;                                             // общее количество страниц памяти на м/сх
                flash.Id    = 68;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x16:                                                          // w25q32 - 32Mbit/4Mb
                flash.Pages = 16384;                                            // общее количество страниц памяти на м/сх
                flash.Id    = 69;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x17:                                                          // w25q64 - 64Mbit/8Mb
                flash.Pages = 32768;                                            // общее количество страниц памяти на м/сх
                flash.Id    = 70;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x18:                                                          // w25q128 - 128Mbit/16Mb
                flash.Pages = 65536;                                            // общее количество страниц памяти на м/сх
                flash.Id    = 71;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x19:                                                          // w25q256 - 256Mbit/32Mb
                flash.Pages = 131072;                                           // общее количество страниц памяти на м/сх
                flash.Id    = 72;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;

            case 0x20:                                                          // w25q512 - 512Mbit/64Mb
                flash.Pages = 262144;                                           // общее количество страниц памяти на м/сх
                flash.Id    = 73;                                               // уникальный номер-идентификатор м/сх (для внутренних нужд)
            break;
        }
        flash.PgSize        = 256;                                              // размер одной страницы памяти в байтах
        flash.ErasableSize  = flash.PgSize << 4;                                // минимальный размер стираемого блока (только для LittleFS)
        flash.NumOfErasable = flash.Pages  >> 4;                                // общее количество стираемых блоков   (только для LittleFS)
        flash.Shift = 0;                                                        // число фиктивных битов сдвига для вычисления абсолютного адреса (для W25QXXX не используется)
    }
    else                                                                        // когда идентификатор производителя неизвестен -> продолжение работы с м/сх памяти не имеет смысла
    {
        flash.Busy          = true;                                             // установка флага занятостиготовности м/сх памяти
        return false;                                                           // возврат неудачной инициализации м/сх
    }
    flash.Busy              = false;                                            // установка флага готовности м/сх памяти
    return true;                                                                // возврат успешной инициализации м/сх
}

bool Flash_IsBusy           (void)                                              // функция ожидания готовности микросхемы Flash-памяти.
{                                                                               // необходимость функции продиктована продолжительным процессом записи. для определения его окончания нужна эта функция.
    uint16_t                status = 0;                                         // подготовка буфера для чтения регистра статуса м/сх памяти
    bool                    isBusy = true;                                      // состояние занятости м/сх памяти: true -> м/сх памяти НЕ готова, false -> м/сх памяти готова для работы.
    Flash_ChipSelect        (true);                                             // разрешение работы с м/сх
    if (flash.Id < 64)                                                          // при работе с AT45DBXXX ->
    {
        Flash_Spi           (AT45_RDSR);                                        // отправка команды:    0xD7 - "считывание регистра состояния"
        status              = Flash_Spi (DUMMY_BYTE);                           // чтение 1-го байта ответа от м/сх памяти
        status              = status | (Flash_Spi (DUMMY_BYTE) << 8);           // чтение 2-го байта ответа от м/сх памяти
        isBusy              = (status & AT45_SR_RDY) == 0;                      // определение занятости м/сх памяти
    }
    else                                                                        // при работе с W25QXX ->
    {
        Flash_Spi           (W25_RDSR1);                                        // отправка команды:    0x05 - "считывание регистра состояния 1"
        status              = Flash_Spi (DUMMY_BYTE);                           // чтение регистра 1 состояния м/сх памяти
        isBusy              = (status & W25_SR1S0) == 1;                        // определение занятости м/сх памяти
    }
    Flash_ChipSelect        (false);                                            // завершение работы с м/сх памяти
    return (isBusy);                                                            // возврат состояния микросхемы памяти: true -> м/сх памяти занята, false -> м/сх памяти готова к приёму команд
}

void Flash_Resume           (void)                                              // функция пробуждения м/сх Flash-памяти после сна
{
    if (flash.Id)                                                               // когда м/сх памяти опознана ->
    {
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх
        Flash_Spi           (FLASH_RESUME);                                     // отправка команды:    0xAB - "возобновление работы после сна"
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
        while               (Flash_IsBusy ());                                  // ожидание готовности микросхемы Flash-памяти
    }
}

void Flash_PowerDown        (void)                                              // функция усыпления м/сх Flash-памяти
{
    if (flash.Id)                                                               // когда м/сх памяти опознана
    {
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх
        Flash_Spi           (FLASH_PWRDOWN);                                    // отправка команды:    0xB9 - "усыпление микросхемы Flash-памяти"
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
    }
}

void Flash_EraseChip        (void)                                              // функция стирания данных из м/сх Flash-памяти
{
    if (flash.Id)                                                               // когда м/сх памяти опознана ->
    {
        while               (flash.Busy);                                       // ждём готовность м/сх памяти
        flash.Busy          = true;                                             // установка флага занятости м/сх памяти
        Flash_Resume        ();                                                 // пробуждение микросхемы памяти
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх
        Flash_WriteEnable   (true);                                             // разрешение записи в память
        Flash_Spi           (FLASH_CHIP_ERASE);                                 // отправка команды:    0xC7 - "стирание чипа"
    
        if (flash.Id < 64)                                                      // особенности очистки чипа при работе с AT45DBXX ->
        {
            Flash_Spi       (AT45_CHIPERASE2);                                  // отправка команды:    0x94 - "стирание чипа - байт 2"
            Flash_Spi       (AT45_CHIPERASE3);                                  // отправка команды:    0x80 - "стирание чипа - байт 3"
            Flash_Spi       (AT45_CHIPERASE4);                                  // отправка команды:    0x9A - "стирание чипа - байт 4"
        }
    
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
        while               (Flash_IsBusy ());                                  // ожидание готовности микросхемы памяти
        Flash_WriteEnable   (false);                                            // запрет записи в память
        flash.Busy          = false;                                            // установка флага готовности м/сх памяти
    }
}

void Flash_EraseArea        (uint32_t area)                                     // функция очистки указанной области на микросхеме Flash-памяти
{
    if (flash.Id)                                                               // когда м/сх памяти опознана ->
    {
        while               (flash.Busy);                                       // ждём готовность м/сх памяти
        flash.Busy          = true;                                             // установка флага занятости м/сх памяти
        uint64_t addr       = 0;                                                // подготовка буфера для формирования абсолютного адреса
        Flash_Resume        ();                                                 // пробуждение микросхемы памяти
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх памяти
        Flash_WriteEnable   (true);                                             // разрешение записи в память
    
        if (flash.Id < 64)                                                      // при работе с AT45DBXX ->
        {
            addr            = area << flash.Shift;                              // вычисление абсолютного адреса страницы путём сдвига на заданное количество бит
            Flash_Spi       (AT45_PGERASE);                                     // отправка команды:    0x81 - "стирание страницы"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка 3 фиктивных битов + PA[11:7]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка PA[6:0] + BA8
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка BA[7:0]
        }
        else                                                                    // при работе с W25QXX ->
        {
            addr            = (area * flash.PgSize) << 4;                       // вычисление абсолютного адреса сектора (=адрес страницы * размер страницы * 16)
            Flash_Spi       (W25_SE);                                           // отправка команды:    0x20 - "стирание сектора"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка A[23:16]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка A[15:8]
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка A[7:0]
        }
    
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
        while               (Flash_IsBusy ());                                  // ожидание готовности микросхемы flash-памяти
        Flash_WriteEnable   (false);                                            // запрет записи в память
        flash.Busy          = false;                                            // установка флага готовности м/сх памяти
    }
}

void Flash_WritePage        (uint32_t page, uint32_t offset,                    // функция записи данных на микросхему Flash-памяти в указанную страницу с заданным смещением
                                                    uint32_t size, uint8_t *buf)
{
    if (flash.Id)                                                               // когда м/сх памяти опознана ->
    {
        while               (flash.Busy);                                       // ждём готовность м/сх памяти
        flash.Busy          = true;                                             // установка флага занятости м/сх памяти
        uint64_t  addr      = 0;
        if (size > flash.PgSize)                                                // проверка размера блока
                size = flash.PgSize;
        Flash_Resume        ();                                                 // пробуждение микросхемы памяти
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх памяти
        Flash_WriteEnable   (true);                                             // разрешение записи в память
    
        if (flash.Id < 64)                                                      // при работе с AT45DBXX ->
        {
            addr            = (page << flash.Shift) + offset;                   // вычисление абсолютного адреса для записи данных  путём сдвига на заданное количество бит с добавлением смещения
            Flash_Spi       (AT45_MNTHRUBF1);                                   // отправка команды:    0x82 - "программирование основной страницы памяти через буфер 1 со встроенным стиранием"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка 3 фиктивных битов + PA[11:7]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка PA[6-0] + BA8
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка BA[7-0]
        }
        else                                                                    // при работе с W25QXX ->
        {
            addr            = (page * flash.PgSize) + offset;                   // вычисление абсолютного адреса для записи данных
            Flash_Spi       (W25_PP);                                           // отправка команды:    0x02 - "программирование страницы памяти"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка A[23:16]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка A[15:8]
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка A[7:0]
        }
    
        HAL_SPI_Transmit    (&_FLASH_SPI, buf, size, 100);                      // запись массива данных в м/сх
    
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
        Flash_WriteEnable   (false);                                            // запрет записи в память
        flash.Busy          = false;                                            // установка флага готовности м/сх памяти
    }
}
    
void Flash_ReadPage         (uint32_t page, uint32_t offset,                    // функция чтения данных из микросхемы Flash-памяти с указанной страницы с заданным смещением
                                                    uint32_t size, uint8_t *buf)
{
    if (flash.Id)                                                               // когда м/сх памяти опознана ->
    {
        while               (flash.Busy);                                       // ждём готовность м/сх памяти
        flash.Busy          = true;                                             // установка флага занятости м/сх памяти
        uint64_t addr       = 0;
        if (size > flash.PgSize)                                                // проверка размера блока
                size = flash.PgSize;
        Flash_Resume        ();                                                 // пробуждение микросхемы памяти
        Flash_ChipSelect    (true);                                             // разрешение работы с м/сх памяти
    
        if (flash.Id < 64)                                                      // при работе с AT45DBXX ->
        {
            addr            = (page << flash.Shift) + offset;                   // вычисление абсолютного адреса
            Flash_Spi       (AT45_RDARRAYHF);                                   // отправка команды:    0x0B - "непрерывное чтение массива"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка 3 фиктивных битов + PA[11:7]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка PA[6-0] + BA8
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка BA[7-0]
            Flash_Spi       (DUMMY_BYTE);                                       // 4й операнд: отправка 8 фиктивных битов
        }
        else                                                                    // при работе с W25QXX ->
        {
            addr            = (page * flash.PgSize) + offset;                   // вычисление абсолютного адреса
            Flash_Spi       (W25_FAST_READ);                                    // отправка команды:    0x0B - "быстрое чтение данных"
            Flash_Spi       ((uint8_t)(addr >> 16));                            // 1й операнд: отправка A[23:16]
            Flash_Spi       ((uint8_t)(addr >>  8));                            // 2й операнд: отправка A[15:8]
            Flash_Spi       ((uint8_t)(addr      ));                            // 3й операнд: отправка A[7:0]
            Flash_Spi       (DUMMY_BYTE);                                       // 4й операнд: отправка 8 фиктивных битов
        }
        HAL_SPI_Receive     (&_FLASH_SPI, buf, size, 100);                      // чтение запрошенного массива данных из м/сх
    
        Flash_ChipSelect    (false);                                            // завершение работы с м/сх памяти
        flash.Busy          = false;                                            // установка флага готовности м/сх памяти
    }
}

// ------------------------------- Функции-прокладки для связки LittleFS и SPI_Flash: -----------------------------------------------------

int block_device_read       (const struct lfs_config *c, lfs_block_t block,     // функция-прокладка для чтения страницы с носителя.
                                   lfs_off_t off, void *buffer, lfs_size_t size)
{
    Flash_ReadPage          ((uint32_t)block, (uint32_t)off,                    // чтение данных на указанной странице с заданным смещением и определенной длины
                                              (uint32_t)size, (uint8_t*)buffer);
	return 0;
}

int block_device_prog       (const struct lfs_config *c, lfs_block_t block,     // функция-прокладка для записи страницы на носитель. страница должна быть заранее очищена.
                             lfs_off_t off, const void *buffer, lfs_size_t size)
{
    Flash_WritePage         ((uint32_t)block, (uint32_t)off,                    // запись данных на указанную страницу с заданным смещением и определенной длины 
                                              (uint32_t)size, (uint8_t*)buffer);
	return 0;
}

int block_device_erase      (const struct lfs_config *c, lfs_block_t block)     // функция-прокладка для удаления области, например, перед записью. состояние стертого блока не определено.
{   
    Flash_EraseArea         ((uint32_t)block);                                  // очистка указанной области
	return 0;
}

int block_device_sync       (const struct lfs_config *c)                        // функция-прокладка для синхронизации состояния носителя. необходима только для носителей с кэшем (не наш случай).
{
	return 0;
}
// ------------------------------------------------------------------------------------------------------------------------------------------
